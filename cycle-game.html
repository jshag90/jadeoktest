<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>자전거 장애물 게임</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #87ceeb;
    font-family: Arial, sans-serif;
  }
  canvas {
    display: block;
    background: linear-gradient(to bottom, #2d3748 0%, #4a5568 100%);
    box-shadow: 0 4px 20px rgba(0,0,0,0.3); /* 그림자 추가 */
    border: 2px solid #333;
  }
  .game-container {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background: linear-gradient(45deg, #2d3748, #4a5568);
  }
</style>
</head>
<body>
<div class="game-container">
  <canvas id="gameCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = 400;
canvas.height = 600;

let bike = { x: 180, y: 500, width: 40, height: 60 };
let obstacles = [];
let powerGels = [];
let waterBottles = [];
let particles = [];
let scorePopups = [];
let score = 0;
let gameSpeed = 2;
let keys = {};
let animationFrame = 0;
let powerBoostTime = 0;
let shieldTime = 0;

document.addEventListener('keydown', (e) => keys[e.key] = true);
document.addEventListener('keyup', (e) => keys[e.key] = false);

// 파티클 효과 생성
function createParticles(x, y, count = 8) {
    for(let i = 0; i < count; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8,
            size: Math.random() * 6 + 2,
            color: `hsl(${Math.random() * 60 + 40}, 100%, 60%)`,
            life: 1,
            decay: Math.random() * 0.02 + 0.01
        });
    }
}

// 점수 팝업 생성
function createScorePopup(x, y, points) {
    scorePopups.push({
        x: x,
        y: y,
        text: `+${points}`,
        life: 1,
        decay: 0.02
    });
}

// 파티클 그리기 및 업데이트
function updateAndDrawParticles() {
    particles.forEach((particle, index) => {
        // 파티클 이동
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life -= particle.decay;
        particle.size *= 0.98;
        
        // 파티클 그리기
        if(particle.life > 0) {
            ctx.save();
            ctx.globalAlpha = particle.life;
            ctx.fillStyle = particle.color;
            ctx.shadowColor = particle.color;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        } else {
            particles.splice(index, 1);
        }
    });
}

// 점수 팝업 그리기 및 업데이트
function updateAndDrawScorePopups() {
    scorePopups.forEach((popup, index) => {
        // 팝업 이동
        popup.y -= 2;
        popup.life -= popup.decay;
        
        // 팝업 그리기
        if(popup.life > 0) {
            ctx.save();
            ctx.globalAlpha = popup.life;
            ctx.fillStyle = '#ffd93d';
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.font = 'bold 20px Arial';
            ctx.shadowColor = '#000';
            ctx.shadowBlur = 3;
            ctx.strokeText(popup.text, popup.x, popup.y);
            ctx.fillText(popup.text, popup.x, popup.y);
            ctx.restore();
        } else {
            scorePopups.splice(index, 1);
        }
    });
}

// 자전거 타는 사람 그리기
function drawBiker(x, y, width, height) {
    const centerX = x + width / 2;
    const centerY = y + height / 2;
    
    ctx.save();
    
    // 파워 부스트 효과
    if(powerBoostTime > 0) {
        ctx.shadowColor = '#ffd93d';
        ctx.shadowBlur = 15;
        ctx.filter = 'brightness(1.2)';
    }
    
    // 자전거 프레임
    ctx.strokeStyle = powerBoostTime > 0 ? '#ff6b6b' : '#333';
    ctx.lineWidth = 3;
    
    // 뒷바퀴
    ctx.beginPath();
    ctx.arc(centerX - 12, centerY + 15, 8, 0, Math.PI * 2);
    ctx.stroke();
    
    // 앞바퀴
    ctx.beginPath();
    ctx.arc(centerX + 12, centerY + 15, 8, 0, Math.PI * 2);
    ctx.stroke();
    
    // 자전거 프레임
    ctx.beginPath();
    ctx.moveTo(centerX - 12, centerY + 15);
    ctx.lineTo(centerX, centerY);
    ctx.lineTo(centerX + 12, centerY + 15);
    ctx.moveTo(centerX, centerY);
    ctx.lineTo(centerX, centerY - 15);
    ctx.stroke();
    
    // 핸들바
    ctx.beginPath();
    ctx.moveTo(centerX - 6, centerY - 12);
    ctx.lineTo(centerX + 6, centerY - 12);
    ctx.stroke();
    
    // 사람 머리
    ctx.fillStyle = '#ffdbac';
    ctx.beginPath();
    ctx.arc(centerX + 2, centerY - 25, 6, 0, Math.PI * 2);
    ctx.fill();
    
    // 헬멧
    ctx.fillStyle = '#ff6b6b';
    ctx.beginPath();
    ctx.arc(centerX + 2, centerY - 27, 7, Math.PI, 2 * Math.PI);
    ctx.fill();
    
    // 몸통
    ctx.fillStyle = '#4ecdc4';
    ctx.fillRect(centerX - 3, centerY - 18, 6, 15);
    
    // 팔 (핸들바 잡는 모양)
    ctx.strokeStyle = '#ffdbac';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(centerX - 3, centerY - 10);
    ctx.lineTo(centerX - 8, centerY - 12);
    ctx.moveTo(centerX + 3, centerY - 10);
    ctx.lineTo(centerX + 8, centerY - 12);
    ctx.stroke();
    
    // 다리 (페달 밟는 모양)
    const pedalOffset = Math.sin(animationFrame * 0.3) * 3;
    ctx.beginPath();
    ctx.moveTo(centerX - 2, centerY - 3);
    ctx.lineTo(centerX - 8, centerY + 8 + pedalOffset);
    ctx.moveTo(centerX + 2, centerY - 3);
    ctx.lineTo(centerX + 8, centerY + 8 - pedalOffset);
    ctx.stroke();
    
    ctx.restore();
}

// 사람 장애물 그리기
function drawPerson(x, y, width, height) {
    const centerX = x + width / 2;
    const centerY = y + height / 2;
    
    ctx.save();
    
    // 머리
    ctx.fillStyle = '#ffdbac';
    ctx.beginPath();
    ctx.arc(centerX, centerY - height/3, width/6, 0, Math.PI * 2);
    ctx.fill();
    
    // 몸통
    ctx.fillStyle = '#ff9f43';
    ctx.fillRect(centerX - width/6, centerY - height/4, width/3, height/2);
    
    // 팔
    ctx.strokeStyle = '#ffdbac';
    ctx.lineWidth = 3;
    const armWave = Math.sin(animationFrame * 0.2) * 5;
    ctx.beginPath();
    ctx.moveTo(centerX - width/6, centerY - height/8);
    ctx.lineTo(centerX - width/3, centerY + armWave);
    ctx.moveTo(centerX + width/6, centerY - height/8);
    ctx.lineTo(centerX + width/3, centerY - armWave);
    ctx.stroke();
    
    // 다리
    const legMove = Math.sin(animationFrame * 0.25) * 3;
    ctx.beginPath();
    ctx.moveTo(centerX - width/12, centerY + height/4);
    ctx.lineTo(centerX - width/8, centerY + height/2 + legMove);
    ctx.moveTo(centerX + width/12, centerY + height/4);
    ctx.lineTo(centerX + width/8, centerY + height/2 - legMove);
    ctx.stroke();
    
    // 얼굴 표정
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(centerX - 2, centerY - height/3 - 1, 1, 0, Math.PI * 2);
    ctx.arc(centerX + 2, centerY - height/3 - 1, 1, 0, Math.PI * 2);
    ctx.fill();
    
    // 입 (놀란 표정)
    ctx.beginPath();
    ctx.arc(centerX, centerY - height/3 + 2, 2, 0, Math.PI);
    ctx.stroke();
    
    ctx.restore();
}

// 파워젤 그리기 (에너지 음료 모양)
function drawPowerGel(x, y, width, height) {
    ctx.save();
    
    // 병 모양
    ctx.fillStyle = '#ffd93d';
    ctx.fillRect(x + 2, y + 4, width - 4, height - 8);
    
    // 캡
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(x + 4, y, width - 8, 6);
    
    // 반짝이는 효과
    ctx.fillStyle = '#fff';
    ctx.fillRect(x + 4, y + 6, 2, height - 10);
    
    // 라벨
    ctx.fillStyle = '#333';
    ctx.font = '8px Arial';
    ctx.fillText('E', x + width/2 - 3, y + height/2 + 2);
    
    ctx.restore();
}

// 수통 그리기 (물 아이템)
function drawWaterBottle(x, y, width, height) {
    ctx.save();
    
    // 수통 본체 (파란색)
    ctx.fillStyle = '#4dabf7';
    ctx.fillRect(x + 1, y + 3, width - 2, height - 6);
    
    // 수통 뚜껑
    ctx.fillStyle = '#228be6';
    ctx.fillRect(x + 3, y, width - 6, 4);
    
    // 물결 무늬 (물 표현)
    ctx.strokeStyle = '#74c0fc';
    ctx.lineWidth = 1;
    for(let i = 0; i < 3; i++) {
        ctx.beginPath();
        const waveY = y + 8 + i * 3;
        const waveOffset = Math.sin((animationFrame * 0.1) + i) * 2;
        ctx.moveTo(x + 3, waveY + waveOffset);
        ctx.quadraticCurveTo(x + width/2, waveY - 1 + waveOffset, x + width - 3, waveY + waveOffset);
        ctx.stroke();
    }
    
    // 반짝이는 효과
    ctx.fillStyle = '#fff';
    ctx.fillRect(x + 2, y + 4, 2, height - 8);
    
    // 라벨
    ctx.fillStyle = '#333';
    ctx.font = '8px Arial';
    ctx.fillText('H2O', x + width/2 - 6, y + height/2 + 2);
    
    ctx.restore();
}

// 배경 도로 그리기
function drawRoad() {
    // 1. 도로 바닥 (회색 아스팔트) - 전체 캔버스를 회색으로 칠함
    ctx.fillStyle = '#2d3748';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 2. 자전거 전용 도로 (붉은색) - 가운데 부분만 빨간색으로 칠함
    ctx.fillStyle = '#c53030';
    ctx.fillRect(60, 0, canvas.width - 120, canvas.height);
    
    // 3. 자전거 전용 도로 테두리 (흰색 실선)
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(60, 0);                    // 왼쪽 경계선 시작
    ctx.lineTo(60, canvas.height);        // 왼쪽 경계선 끝
    ctx.moveTo(canvas.width - 60, 0);     // 오른쪽 경계선 시작
    ctx.lineTo(canvas.width - 60, canvas.height); // 오른쪽 경계선 끝
    ctx.stroke();
    
    // 4. 도로 선 애니메이션을 위한 오프셋 계산
    const roadOffset = powerBoostTime > 0 ? (animationFrame * 3) % 20 : (animationFrame * 0.5) % 20;
    
    // 5. 중앙선 (노란색 점선) - 자전거 도로 중앙
    ctx.strokeStyle = powerBoostTime > 0 ? '#ffd93d' : '#f6e05e';
    ctx.lineWidth = 2;
    ctx.setLineDash([10, 10]);            // 점선 패턴: 10px 선, 10px 공백
    ctx.lineDashOffset = -roadOffset;     // 점선이 위로 움직이는 효과
    
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, 0);
    ctx.lineTo(canvas.width / 2, canvas.height);
    ctx.stroke();
    
    // 6. 자전거 도로 양쪽 내부 안내선 (흰색 점선)
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);              // 더 짧은 점선
    
    // 좌측 내부선 (경계선에서 20px 안쪽)
    ctx.beginPath();
    ctx.moveTo(80, 0);
    ctx.lineTo(80, canvas.height);
    ctx.stroke();
    
    // 우측 내부선
    ctx.beginPath();
    ctx.moveTo(canvas.width - 80, 0);
    ctx.lineTo(canvas.width - 80, canvas.height);
    ctx.stroke();
    
    ctx.setLineDash([]);                  // 점선 설정 초기화
    
    // 7. 자전거 마크 아이콘들 (도로 위에 주기적으로 표시)
    ctx.fillStyle = '#ffffff';
    ctx.globalAlpha = 0.3;                // 반투명하게
    for(let i = 0; i < 5; i++) {
        // y 위치 계산: 위로 이동하면서 반복
        const y = (animationFrame * 2 + i * 150) % (canvas.height + 150) - 50;
        if(y > -50 && y < canvas.height) { // 화면에 보이는 경우만
            drawBikeIcon(canvas.width / 2 - 15, y);
        }
    }
    ctx.globalAlpha = 1;                  // 투명도 원복
}

function drawBikeIcon(x, y) {
    ctx.save();                           // 현재 스타일 저장
    ctx.strokeStyle = '#ffffff';          // 흰색으로 그리기
    ctx.lineWidth = 2;
    
    // 1. 자전거 바퀴 두 개 그리기
    ctx.beginPath();
    ctx.arc(x + 5, y + 10, 4, 0, Math.PI * 2);  // 왼쪽 바퀴 (원)
    ctx.arc(x + 20, y + 10, 4, 0, Math.PI * 2); // 오른쪽 바퀴 (원)
    ctx.stroke();
    
    // 2. 자전거 프레임 그리기
    ctx.beginPath();
    ctx.moveTo(x + 5, y + 10);            // 왼쪽 바퀴 중심에서 시작
    ctx.lineTo(x + 12.5, y);              // 상단 중앙으로
    ctx.lineTo(x + 20, y + 10);           // 오른쪽 바퀴 중심으로
    ctx.moveTo(x + 12.5, y);              // 상단 중앙에서 시작
    ctx.lineTo(x + 12.5, y + 5);          // 시트 포스트
    ctx.stroke();
    
    ctx.restore();                        // 원래 스타일 복원
}

function spawnObstacle() {
    let width = 40;
    let x = Math.random() * (canvas.width - width - 100) + 50;
    obstacles.push({x, y: -80, width, height: 60});
}

function spawnPowerGel() {
    let size = 20;
    let x = Math.random() * (canvas.width - size - 100) + 50;
    powerGels.push({x, y: -20, width: size, height: size});
}

function spawnWaterBottle() {
    let size = 18;
    let x = Math.random() * (canvas.width - size - 100) + 50;
    waterBottles.push({x, y: -18, width: size, height: size});
}

let gameOver = false; // 전역 변수

function update() {
    animationFrame++;
    
    // 파워 부스트 시간 감소
    if(powerBoostTime > 0) {
        powerBoostTime--;
    }
    
    // 보호막 시간 감소
    if(shieldTime > 0) {
        shieldTime--;
    }
    
    // 이동 (도로 경계 내에서만)
    const moveSpeed = powerBoostTime > 0 ? 8 : 5;
    if(keys['ArrowLeft'] && bike.x > 60) bike.x -= moveSpeed;
    if(keys['ArrowRight'] && bike.x + bike.width < canvas.width - 60) bike.x += moveSpeed;

    // 파워 부스트 시 더 빠른 게임 속도
    const currentGameSpeed = powerBoostTime > 0 ? gameSpeed * 2.5 : gameSpeed;

    // 장애물 이동 (파워 부스트 시 더 빠르게)
    obstacles.forEach(obs => obs.y += currentGameSpeed);
    obstacles = obstacles.filter(obs => obs.y < canvas.height);

    // 파워젤 이동
    powerGels.forEach(p => p.y += currentGameSpeed);
    powerGels = powerGels.filter(p => p.y < canvas.height);
    
    // 수통 이동
    waterBottles.forEach(w => w.y += currentGameSpeed);
    waterBottles = waterBottles.filter(w => w.y < canvas.height);

    // 충돌 체크 (보호막이 있으면 무시)
    if(!gameOver && shieldTime <= 0) {
        obstacles.forEach(obs => {
            if(bike.x < obs.x + obs.width - 10 && bike.x + bike.width - 10 > obs.x &&
               bike.y < obs.y + obs.height - 10 && bike.y + bike.height - 10 > obs.y) {
			   gameOver = true; // 한 번만 실행
                alert("게임 종료! 점수: " + Math.floor(score));
                document.location.reload();
				
            }
        });
    }

    // 파워젤 획득
    powerGels.forEach((p, index) => {
        if(bike.x < p.x + p.width && bike.x + bike.width > p.x &&
           bike.y < p.y + p.height && bike.y + bike.height > p.y) {
            
            const points = 10;
            score += points;
            powerBoostTime = 180; // 3초간 파워 부스트
            
            // 노란색 파티클 효과
            createParticles(p.x + p.width/2, p.y + p.height/2, 12);
            createScorePopup(p.x, p.y - 10, points);
            
            powerGels.splice(index, 1);
        }
    });
    
    // 수통 획득
    waterBottles.forEach((w, index) => {
        if(bike.x < w.x + w.width && bike.x + bike.width > w.x &&
           bike.y < w.y + w.height && bike.y + bike.height > w.y) {
            
            const points = 5;
            score += points;
            shieldTime = 300; // 5초간 보호막
            
            // 파란색 파티클 효과
            for(let i = 0; i < 10; i++) {
                particles.push({
                    x: w.x + w.width/2,
                    y: w.y + w.height/2,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    size: Math.random() * 6 + 2,
                    color: `hsl(${200 + Math.random() * 40}, 100%, 60%)`,
                    life: 1,
                    decay: Math.random() * 0.02 + 0.01
                });
            }
            createScorePopup(w.x, w.y - 10, points);
            
            waterBottles.splice(index, 1);
        }
    });

    // 점수 증가 및 게임 속도 증가
    score += 0.02;
    if(Math.floor(score) % 50 === 0) {
        gameSpeed = Math.min(gameSpeed + 0.001, 4);
    }
}

function draw() {
    // 배경 그라디언트 (파워 부스트 시 더 역동적)
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
	if(powerBoostTime > 0) {
		gradient.addColorStop(0, '#4a5568');
		gradient.addColorStop(0.5, '#ffd93d');
		gradient.addColorStop(1, '#ff6b6b');
	} else {
		gradient.addColorStop(0, '#718096');
		gradient.addColorStop(0.5, '#a0aec0');
		gradient.addColorStop(1, '#e2e8f0');
	}
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 파워 부스트 시 배경에 스피드 라인 효과
    if(powerBoostTime > 0) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 2;
        for(let i = 0; i < 10; i++) {
            const x = Math.random() * canvas.width;
            const speed = 8 + Math.random() * 12;
            const y = (animationFrame * speed + i * 60) % (canvas.height + 100);
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - 20, y - 40);
            ctx.stroke();
        }
    }
    
    // 도로 그리기
    drawRoad();

    // 자전거 타는 사람
    drawBiker(bike.x, bike.y, bike.width, bike.height);

    // 사람 장애물들
    obstacles.forEach(obs => drawPerson(obs.x, obs.y, obs.width, obs.height));

    // 파워젤
    powerGels.forEach(p => drawPowerGel(p.x, p.y, p.width, p.height));
    
    // 수통
    waterBottles.forEach(w => drawWaterBottle(w.x, w.y, w.width, w.height));

    // 파티클 효과
    updateAndDrawParticles();
    
    // 점수 팝업
    updateAndDrawScorePopups();

    // 점수 및 속도 표시
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px Arial';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.strokeText('점수: ' + Math.floor(score), 10, 30);
    ctx.fillText('점수: ' + Math.floor(score), 10, 30);
    
    ctx.font = '14px Arial';
    const displaySpeed = powerBoostTime > 0 ? (gameSpeed * 2.5).toFixed(1) : gameSpeed.toFixed(1);
    ctx.strokeText('속도: ' + displaySpeed, 10, 55);
    ctx.fillText('속도: ' + displaySpeed, 10, 55);
    
    // 파워 부스트 상태 표시
    if(powerBoostTime > 0) {
        // 깜빡이는 효과
        const flashAlpha = Math.sin(animationFrame * 0.3) * 0.3 + 0.7;
        ctx.globalAlpha = flashAlpha;
        
        ctx.fillStyle = '#ffd93d';
        ctx.strokeStyle = '#ff6b6b';
        ctx.font = 'bold 18px Arial';
        ctx.strokeText('⚡ SPEED BOOST! ⚡', 10, 80);
        ctx.fillText('⚡ SPEED BOOST! ⚡', 10, 80);
        
        ctx.globalAlpha = 1;
        
        // 파워 부스트 게이지
        const gaugeWidth = 120;
        const gaugeHeight = 10;
        const gaugeX = 10;
        const gaugeY = 85;
        
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.strokeRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
        
        // 게이지 배경
        ctx.fillStyle = '#333';
        ctx.fillRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
        
        // 게이지 채우기 (그라디언트)
        const gaugeGradient = ctx.createLinearGradient(gaugeX, gaugeY, gaugeX + gaugeWidth, gaugeY);
        gaugeGradient.addColorStop(0, '#ff6b6b');
        gaugeGradient.addColorStop(0.5, '#ffd93d');
        gaugeGradient.addColorStop(1, '#4ecdc4');
        
        ctx.fillStyle = gaugeGradient;
        const fillWidth = (powerBoostTime / 180) * gaugeWidth;
        ctx.fillRect(gaugeX, gaugeY, fillWidth, gaugeHeight);
    }
    
    // 보호막 상태 표시
    if(shieldTime > 0) {
        // 보호막 효과를 자전거 주변에 그리기
        ctx.save();
        ctx.globalAlpha = 0.3 + Math.sin(animationFrame * 0.2) * 0.2;
        ctx.strokeStyle = '#4dabf7';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#4dabf7';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(bike.x + bike.width/2, bike.y + bike.height/2, 35, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        
        // 보호막 텍스트 표시
        const shieldFlashAlpha = Math.sin(animationFrame * 0.2) * 0.3 + 0.7;
        ctx.globalAlpha = shieldFlashAlpha;
        
        ctx.fillStyle = '#4dabf7';
        ctx.strokeStyle = '#228be6';
        ctx.font = 'bold 16px Arial';
        const shieldY = powerBoostTime > 0 ? 120 : 80;
        ctx.strokeText('🛡️ SHIELD ACTIVE! 🛡️', 10, shieldY);
        ctx.fillText('🛡️ SHIELD ACTIVE! 🛡️', 10, shieldY);
        
        ctx.globalAlpha = 1;
        
        // 보호막 게이지
        const shieldGaugeWidth = 120;
        const shieldGaugeHeight = 8;
        const shieldGaugeX = 10;
        const shieldGaugeY = shieldY + 5;
        
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(shieldGaugeX, shieldGaugeY, shieldGaugeWidth, shieldGaugeHeight);
        
        // 게이지 배경
        ctx.fillStyle = '#333';
        ctx.fillRect(shieldGaugeX, shieldGaugeY, shieldGaugeWidth, shieldGaugeHeight);
        
        // 보호막 게이지 채우기
        ctx.fillStyle = '#4dabf7';
        const shieldFillWidth = (shieldTime / 300) * shieldGaugeWidth;
        ctx.fillRect(shieldGaugeX, shieldGaugeY, shieldFillWidth, shieldGaugeHeight);
    }
    
    // 조작법 표시
    ctx.font = '12px Arial';
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fillText('← → 키로 이동', 10, canvas.height - 10);
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// 주기적으로 장애물과 파워젤, 수통 생성
setInterval(spawnObstacle, 1500);
// 파워젤 생성 간격을 4초에서 2.5초로 줄여서 더 자주 나오게 수정
setInterval(spawnPowerGel, 2500);
// 수통은 3.5초마다 생성
setInterval(spawnWaterBottle, 3500);

// 게임 시작
gameLoop();
</script>
</body>
</html>